% Chapter 4

\chapter{Architecture}

\label{ch:architecture}

%----------------------------------------------------------------------------------------

\section{Overview}\label{sec:architecture:overview}

\tangible{} is implemented as a single Python package, without any external
dependencies.

The architecture of \tangible{} can be categorized into four different
components: The abstract syntax tree \eqref{sec:architecture:ast}, code
generation backends \eqref{sec:architecture:backends}, shapes
\eqref{sec:architecture:shapes} and utils \eqref{sec:architecture:utils}.

\vspace{7mm}

%----------------------------------------------------------------------------------------

\section{AST}\label{sec:architecture:ast}

The \texttt{ast.py} module provides the objects for the abstract syntax tree
(AST) for \tangible{}. All AST objects extend a single base class called
\texttt{AST}. This base class is responsible for three things:

\begin{itemize}
	\item It provides a single base type that can be used for type checking, e.g.
		\texttt{isinstance(mysubclass, ast.AST)}.
	\item It overrides the \texttt{\_\_eq\_\_} and \texttt{\_\_ne\_\_} methods,
		with the result that all subclasses are compared by value (using
		\texttt{self.\_\_dict\_\_}), and not by identity.
	\item It provides a \texttt{\_\_repr\_\_} implementation that displays both
		the class name as well as the object memory address, which simplifies
		debugging.
\end{itemize}

\noindent The module contains the following classes:

\subsection{Base Class}

\begin{itemize}
	\item \texttt{AST}: The base shape for all AST elements, as described above.
\end{itemize}

\subsection{2D Shapes}

\begin{itemize}
	\item \texttt{Circle}: A circle shape with a specified radius.
	\item \texttt{CircleSector}: A circle sector shape (pizza slice) with a
		specified radius and angle.
	\item \texttt{Rectangle}: A rectangular shape with a specified width and
		height.
	\item \texttt{Polygon}: A polygon shape made from a list of 2D coordinates.
\end{itemize}

\subsection{3D Shapes}

\begin{itemize}
	\item \texttt{Cube}: A cube with a specified width, height and depth.
	\item \texttt{Sphere}: A sphere with a specified radius.
	\item \texttt{Cylinder}: A cylinder with a height and top/bottom radii.
	\item \texttt{Polyhedron}: An arbitrary 3D shape made from connected triangles
		or quads.
\end{itemize}

\subsection{Transformations}

\begin{itemize}
	\item \texttt{Translate}: Used to translate an object.
	\item \texttt{Rotate}: Used to rotate an object.
	\item \texttt{Scale}: Used to scale an object.
	\item \texttt{Mirror}: Used to mirror an object.
\end{itemize}

\subsection{Boolean Operations}

\begin{itemize}
	\item \texttt{Union}: A combination of multiple shapes into a single shape.
	\item \texttt{Difference}: A boolean difference of two or more shapes.
	\item \texttt{Intersection}: A boolean intersection of two or more shapes.
\end{itemize}

\subsection{Extrusions}

\begin{itemize}
	\item \texttt{LinearExtrusion}: An extrusion of a 2D object linearly along the
		z axis.
	\item \texttt{RotateExtrusion}: An extrusion of a 2D object around the z axis. 
\end{itemize}

%----------------------------------------------------------------------------------------

\section{Backends}\label{sec:architecture:backends}

The backends are responsible for code generation. They receive an
\hyperref[sec:architecture:ast]{AST} instance, traverse it and emit backend specific code.

At the time of this writing, only one backend has been implemented: The OpenSCAD
backend. But it would be very easy to add additional backends in the future.

\subsection{Creating Custom Backends}

\marginpar{In duck typed programming languages like Python, interfaces are
usually not declared explicitly. The adherence to the interface is only judged
by the behavior of the implementation: If it looks like a duck, swims like a
duck, and quacks like a duck, then it probably is a duck.}

To be valid, a custom backend simply needs to implement the following interface:

\vspace{.5\baselineskip}
\begin{pythoncode}
class CustomBackend(object):
    def __init__(self, ast):
        """Initialize backend using the provided AST."""
    def generate(self):
        """Generate code from AST and return it
        as a unicode string."""
\end{pythoncode}

\noindent The code generated by a backend is returned as a unicode string. It
can then be printed to the terminal or used for further processing.

Implementation details regarding the already existing backend can be found in
section \ref{sec:design:codegen}.

%----------------------------------------------------------------------------------------

\section{Shapes}\label{sec:architecture:shapes}

The \texttt{shapes} package is a key component of \tangible{}. It provides a
hierarchical collection of predefined shapes that can be used directly to
generate three dimensional data visualizations.

\vspace{.5\baselineskip}

\noindent The package is organized into different files:

\begin{itemize}
	\item \texttt{base.py}: Base classes for all shape objects.
	\item \texttt{mixins.py}: Mixins used in the shape classes, mostly used for
		data validation.
	\item \texttt{bars.py}: Bar like shapes.
	\item \texttt{vertical.py}: Vertical shapes, e.g. towers.
	\item \texttt{pie.py}: Circular "pie" shapes.
\end{itemize}


\subsection{Base Class}

The class \texttt{Shape} in \texttt{shapes/base.py} is the base class for all
predefined shapes in \tangible{}:

\vspace{.5\baselineskip}

\begin{pythoncode}
class BaseShape(object):
    def _build_ast(self):
        raise NotImplementedError("_build_ast method not implemented.")

    def render(self, backend):
        ast = self._build_ast()
        return backend(ast).generate()
    
class Shape(BaseShape):
    def __init__(self, data):
        self.data = utils.ensure_list_of_lists(data)
        if len(self.data[0]) == 0:
            raise ValueError("Data may not be empty.")
\end{pythoncode}

\noindent Each shape is initialized with the data as the first positional
argument. Using a helper function, single lists with one dimensional data are
converted to nested lists, to simplify the rendering code. Empty data is not
allowed.

The \texttt{\_build\_ast()} method is not implemented in the base class. An
inheriting class needs to override the method and return an AST.

Finally, the \texttt{render(backend)} method renders the AST using the specified
backend class and returns the resulting source code as a unicode string, as
described in section \ref{sec:architecture:backends}.

\subsection{Mixins}

The mixin classes are used in combination with Python's multiple inheritance
system to provide "pluggable" generic data validation. At the time of this
writing, the following mixins are available:

\begin{itemize}
	\item \texttt{Data1DMixin}: Ensures that data contains exactly 1 dataset.
	\item \texttt{Data2DMixin}: Ensures that data contains exactly 2 datasets.
	\item \texttt{Data3DMixin}: Ensures that data contains exactly 3 datasets.
	\item \texttt{Data4DMixin}: Ensures that data contains exactly 4 datasets.
	\item \texttt{DataNDMixin}: Used for shapes where the number of data
		dimensions is not relevant. But it asserts that the data is not empty and
		that all data items are of a sequence type.
	\item \texttt{SameLengthDatasetMixin}: Ensures that all datasets have the same
		length.
\end{itemize}

\noindent The mixins are properly implemented using Python's argument list
unpacking (\texttt{\textsuperscript{*}args, \textsuperscript{**}kwargs}) and
\texttt{super()} calls, so that a class can use multiple mixins without breaking
the inheritance chain. A good example where this is used is the
\texttt{RectangleTower2D} shape:

\vspace{.5\baselineskip}

\begin{pythoncode}
class RectangleTower2D(Data2DMixin,
    SameLengthDatasetMixin, VerticalShape):
    # ...
\end{pythoncode}

\subsection{Shape Classes}\label{subsec:architecture:shapes:classes}

The final shape classes are grouped into three categories: Bar shapes, vertical
shapes and pie shapes.

\begin{itemize}
	\item Bar shapes consist of several bars that start on \texttt{z=0} and have a
		height depending on the corresponding datapoint. They can be aligned in
		rows, and rows can be combined to create 3D bar graphs.
	\item A vertical shape is a shape with layers stacked on top of each other,
		with a fixed layer height, for example a round tower where the radius of
		each layer corresponds to the datapoint.
	\item A pie shape can represent data as angle, height or radius of the
		corresponding slice. It is also possible to define an inner radius
		($\rightarrow$donut) and to explode the slices.
\end{itemize}

\noindent The naming of the shape classes follows a consistent pattern: First a
descriptive name of the shape (e.g. \texttt{RhombusTower} or
\texttt{RadiusHeightPie}), then the dimensionality of the data (e.g.
\texttt{1D}, \texttt{4D} or \texttt{ND}). A way to describe data dimensionality
in Python terms would be: \emph{\texttt{n}-dimensional data is a list containing
\texttt{n} lists}.

%----------------------------------------------------------------------------------------

\section{Utils}\label{sec:architecture:utils}

\subsection{Scales}

The module \texttt{scales.py} contains functions for mapping an input domain to
an output range (the codomain). For example it could be used to normalize
temperatures between 0\si{\degree}C and 100\si{\degree}C to values between 1 and
10. The scales are inspired by the quantitative scales in
\texttt{d3.js}\footnote{\url{https://github.com/mbostock/d3/wiki/Quantitative-Scales}}.

At the time of this writing, only a linear scale has been implemented. It
accepts three parameters: The domain, the codomain (output range), and whether
to clamp the values to the output range or not.

\vspace{.5\baselineskip}
\begin{pythoncode}
>>> from tangible import scales
>>> temperatures = [32, 60, 100, 0, 120, -50]
>>> domain = [0, 100]  # Input range
>>> codomain = [1, 10]  # Output range
>>> scale = scales.linear(domain, codomain, clamp=False)
>>> scale_clamp = scales.linear(domain, codomain=, clamp=True)
\end{pythoncode}

\noindent The returned object is the actual scaling function:

\vspace{.5\baselineskip}
\begin{pythoncode}
>>> scale(0)
1.0
>>> scale(50)
5.5
>>> scale(100)
10.0
\end{pythoncode}

\noindent A very convenient way to use scales is by applying them using the
\texttt{map()} function:

\vspace{.5\baselineskip}
\begin{pythoncode}
>>> map(scale, temperatures)
[3.88, 6.3999999999999995, 10.0, 1.0, 11.799999999999999, -3.5]
>>> map(scale_clamp, temperatures)
[3.88, 6.3999999999999995, 10.0, 1.0, 10, 1]
\end{pythoncode}

\noindent Logarithmic and exponential scales as well as dynamic resizing of
domains / codomains are currently not implemented, but will follow in the
future.

\subsection{Helper Functions}

The module \texttt{utils.py} contains different helper functions to simplify
common tasks.


\subsubsection{\texttt{pairwise(iterable)}}\label{subsec:architecture:pairwise}

\noindent This function returns a generator acting as a sliding window over an iterable.
Each item returned by the generator is a 2-tuple containing two consecutive
items from the original iterable.

\vspace{.5\baselineskip}

\noindent Example:

\vspace{.5\baselineskip}
\begin{pythoncode}
>>> from tangible import utils
>>> pairs = utils.pairwise([1, 2, 3, 4, 'a'])
>>> pairs
<itertools.izip object at 0xeea098>
>>> list(pairs)
[(1, 2), (2, 3), (3, 4), (4, 'a')]
\end{pythoncode}


\subsubsection{\texttt{reduceby(iterable, keyfunc, reducefunc, init)}}

This function combines the functionality of \texttt{itertools.groupby()} and
\texttt{reduce()}. It iterates over the iterable and aggregates the values using
the specified reduce function and init value as long as \texttt{keyfunc(item)}
returns the same value. Each time the key changes, the aggregated value is
yielded.

A possible use case could be the aggregation of website visits, grouped by
month. Example:

\vspace{.5\baselineskip}
\begin{pythoncode}
>>> from datetime import date
>>> from tangible import utils
>>> visits = [(date(2013, 1, 24), 27),
...           (date(2013, 1, 26), 4),
...           (date(2013, 2, 17), 19),
...           (date(2013, 3, 11), 23),
...           (date(2013, 3, 14), 42)]
>>> keyfunc = lambda x: x[0].month
>>> reducefunc = lambda x, y: x + y[1]
>>> groups = utils.reduceby(visits, keyfunc, reducefunc, 0)
>>> groups
<generator object reduceby at 0xedc5a0>
>>> list(groups)
[31, 19, 65]
\end{pythoncode}

\noindent The corresponding SQL statement would be:

\vspace{.5\baselineskip}
\begin{minted}[bgcolor=tango-bg,frame=lines,framesep=2mm,samepage=true,fontsize=\footnotesize]{sql}
SELECT SUM(visit_count) FROM visits GROUP BY MONTH(visit_date);
\end{minted}




\subsubsection{\texttt{connect\_2d\_shapes(shapes,layer\_distance, orientation)}}

This is quite a complex function. It connects a list of 2D shapes into a 3D
shape using the desired layer distance. The \texttt{orientation} argument
specifies, whether the shapes should be joined horizontally or vertically.

\noindent The main part of the function has separate implementations depending
on the 2D object. Circles are connected by joining cylinders, while rectangles
and polygons are connected by joining polyhedra.

\vspace{.5\baselineskip}

\noindent Example:

\vspace{.5\baselineskip}
\begin{pythoncode}
>>> from tangible import utils, ast
>>> shapes = [ast.Circle(3), ast.Circle(8), ast.Circle(5)]
>>> utils.connect_2d_shapes(shapes, layer_distance=10,
...     orientation='vertical')
<AST/Union: 21376464>
\end{pythoncode}


\subsubsection{\texttt{\_quads\_to\_triangles(quads)}}

This function converts a list of quads (4-tuples) to a list of triangles
(3-tuples). This is mostly because many backends require surface meshes to
consist of triangles, without support for quads.

\vspace{.5\baselineskip}

\noindent Example:

\vspace{.5\baselineskip}
\begin{pythoncode}
>>> from tangible import utils
>>> quads = [(0, 1, 2, 3)]
>>> utils._quads_to_triangles(quads)
[(0, 1, 2), (0, 2, 3)]
\end{pythoncode}

\noindent The function is mostly used internally. A stable API is not guaranteed.


\subsubsection{\texttt{\_ensure\_list\_of\_lists(data)}}

This function ensures that the argument is a list of lists. If it doesn't
contain lists or tuples, it is wrapped in a list and returned.

\vspace{.5\baselineskip}

\noindent Example:

\vspace{.5\baselineskip}
\begin{pythoncode}
>>> utils._ensure_list_of_lists([1, 2, 3])
[[1, 2, 3]]
>>> utils._ensure_list_of_lists([[1, 2], [3]])
[[1, 2], [3]]
\end{pythoncode}

\noindent The function is mostly used internally. A stable API is not guaranteed.
